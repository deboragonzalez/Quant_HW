---
title: "HW1_Notes"
author: "Debi Gonzalez"
date: "2025-09-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Lesson #2
> getwd()
[1] "/Users/debig/Documents/Psych Research 2025/Quant_HW"

> ls()
[1] "my_div"  "my_sqrt" "x"       "y"       "z"    

> list.files()
[1] "HW1.html"       "HW1.Rmd"        "Quant_HW.Rproj"
dir.create("testdir")
Set working directory: > setwd("testdir")

Create new file within working directory: > file.create("mytest.R")
Check files in working directory: > list.files()
[1] "mytest.R"

> file.exists("mytest.R")
[1] TRUE


> file.info("mytest.R")
         size isdir mode               mtime               ctime
mytest.R    0 FALSE  644 2025-09-04 14:47:33 2025-09-04 14:47:39
                       atime uid gid uname grname
mytest.R 2025-09-04 14:47:33 501  20 debig  staff

Changing File name: > file.rename("mytest.R","mytest2.R")
[1] TRUE

Making a copy: > file.copy("mytest2.R","mytest3.R")
[1] TRUE

Provide the relative path to the file "mytest3.R" by using file.path().

> file.path("mytest3.R")
[1] "mytest3.R"

You can use file.path to construct file and directory paths that are
| independent of the operating system your R code is running on. Pass 'folder1'
| and 'folder2' as arguments to file.path to make a platform-independent
| pathname.

> file.path('folder1','folder2')
[1] "folder1/folder2"

| Create a directory in the current working directory called "testdir2" and a
| subdirectory for it called "testdir3", all in one command by using
| dir.create() and file.path().

> dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)

Go back to your original working directory using setwd(). (Recall that we
| created the variable old.dir with the full path for the orginal working
| directory at the start of these questions.)
> setwd(old.dir)

  |================================================================       |  90%
| It is often helpful to save the settings that you had before you began an
| analysis and then go back to them at the end. This trick is often used within
| functions; you save, say, the par() settings that you started with, mess
| around a bunch, and then set them back to the original values at the end. This
| isn't the same as what we have done here, but it seems similar enough to
| mention.


Lesson 3: Vectors

| Pull up the documentation for `:` now.

> ?`:`


> seq(1,20)
> seq(0, 10, by=0.5)

> my_seq <- seq(5, 10, length=30)

Checking length:
> length(my_seq)

Let's pretend we don't know the length of my_seq, but we want to generate a
| sequence of integers from 1 to N, where N represents the length of the my_seq
| vector. In other words, we want a new vector (1, 2, 3, ...) that is the same
| length as my_seq.

Three different ways of doing this:
> 1:length(my_seq)
> seq(along.with = my_seq)
> seq_along(my_seq)

| If we're interested in creating a vector that contains 40 zeros, we can use
| rep(0, times = 40). Try it out.

> rep(0, times=40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[39] 0 0

| If instead we want our vector to contain 10 repetitions of the vector (0, 1,
| 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.

> rep(c(0,1,2), times=10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
 
 Finally, let's say that rather than repeating the vector (0, 1, 2) over and
| over again, we want our vector to contain 10 zeros, then 10 ones, then 10
| twos. We can do this with the `each` argument. Try rep(c(0, 1, 2), each = 10).

> rep(c(0,1,2), each=10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2
 
 Lesson 4 Vectors
| The simplest and most common data structure in R is the vector.
| Vectors come in two different flavors: atomic vectors and lists. An atomic
| vector contains exactly one data type, whereas a list may contain multiple
| data types. We'll explore atomic vectors further before we get to lists.
| In previous lessons, we dealt entirely with numeric vectors, which are one
| type of atomic vector. Other types of atomic vectors include logical,
| character, integer, and complex. In this lesson, we'll take a closer look at
| logical and character vectors.

| Logical vectors can contain the values TRUE, FALSE, and NA (for 'not
| available'). These values are generated as the result of logical 'conditions'.
| Let's experiment with some simple conditions.

First, create a numeric vector num_vect that contains the values 0.5, 55, -10,
| and 6.
> num_vect <- c(0.5, 55, -10, 6)

| Now, create a variable called tf that gets the result of num_vect < 1, which
| is read as 'num_vect is less than 1'.

> tf <- num_vect < 1

> tf
[1]  TRUE FALSE  TRUE FALSE

| The statement num_vect < 1 is a condition and tf tells us whether each
| corresponding element of our numeric vector num_vect satisfies this condition.

Now, without assigning to a variable:
> num_vect >= 6
[1] FALSE  TRUE FALSE  TRUE

| This time, we are asking whether each individual element of num_vect is
| greater than OR equal to 6. Since only 55 and 6 are greater than or equal to
| 6, the second and fourth elements of the result are TRUE and the first and
| third elements are FALSE.

| The `<` and `>=` symbols in these examples are called 'logical operators'.
| Other logical operators include `>`, `<=`, `==` for exact equality, and `!=`
| for inequality.

| If we have two logical expressions, A and B, we can ask whether at least one
| is TRUE with A | B (logical 'or' a.k.a. 'union') or whether they are both TRUE
| with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is the negation
| of A and is TRUE when A is FALSE and vice versa.

  |==============================                                         |  42%
| (3 > 5) & (4 == 4)

1: TRUE
2: FALSE

Selection: 2

| You got it right!

  |================================                                       |  45%
| (TRUE == TRUE) | (TRUE == FALSE)

1: FALSE
2: TRUE

Selection: 2

| Keep working like that and you'll get there!

  |==================================                                     |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: TRUE
2: FALSE

Selection: 1

| You are really on a roll!

Character vectors are also very common in R. Double quotes are used to
| distinguish character objects, as in the following example. Create a character vector that contains the following words: "My", "name", "is". Remember to enclose each word in its own set of double quotes, so that R
| knows they are character strings. Store the vector in a variable called
| my_char.

> my_char <- c("My", "name", "is")
> my_char

[1] "My"   "name" "is" 

Right now, my_char is a character vector of length 3. Let's say we want to
| join the elements of my_char together into one continuous character string
| (i.e. a character vector of length 1). We can do this using the paste()
| function.Type paste(my_char, collapse = " ") now. Make sure there's a space between the double quotes in the `collapse` argument. You'll see why in a second.

paste(my_char, collapse = " ")
The `collapse` argument to the paste() function tells R that when we join together the elements of the my_char character vector, we'd like to separate them with single spaces.

To add (or 'concatenate') your name to the end of my_char, use the c()
| function like this: c(my_char, "your_name_here"). Place your name in double
| quotes where I've put "your_name_here". Try it now, storing the result in a
| new variable called my_name.
> my_name <- c(my_char, "Debi")

> my_name
[1] "My"   "name" "is"   "Debi"

> paste(my_name, collapse = " ")
[1] "My name is Debi"

In this example, we used the paste() function to collapse the elements of a
| single character vector. paste() can also be used to join the elements of
| multiple character vectors.

| In the simplest case, we can join two character vectors that are each of
| length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "), where the `sep` argument tells R that we want to separate the joined elements with a single space.

| For a slightly more complicated example, we can join two vectors, each of
| length 3. Use paste() to join the integer vector 1:3 with the character vector
| c("X", "Y", "Z"). This time, use sep = "" to leave no space between the joined
| elements.

> paste(1:3,c("X","Y","Z"), sep = "")
[1] "1X" "2Y" "3Z"

| What do you think will happen if our vectors are of different length? (Hint:
| we talked about this in a previous lesson.)
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a
| predefined variable in R containing a character vector of all 26 letters in
| the English alphabet.

> paste(LETTERS, 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
[13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
[25] "Y-1" "Z-2"

| Also worth noting is that the numeric vector 1:4 gets 'coerced' into a
| character vector by the paste() function.
| We'll discuss coercion in another lesson, but all it really means is that the
| numbers 1, 2, 3, and 4 in the output above are no longer numbers to R, but
| rather characters "1", "2", "3", and "4".

Lesson 5: Missing Values
| Missing values play an important role in statistics and data analysis. Often,
| missing values must not be ignored, but rather they should be carefully
| studied to see if there's an underlying pattern or cause for their
| missingness.
| In R, NA is used to represent any value that is 'not available' or 'missing'
| (in the statistical sense). In this lesson, we'll explore missing values
| further.

| Any operation involving NA generally yields NA as the result. To illustrate,
| let's create a vector c(44, NA, 5, NA) and assign it to a variable x.

> x <- c(44, NA, 5, NA)
> x*3
[1] 132  NA  15  NA

| To make things a little more interesting, lets create a vector containing 1000
| draws from a standard normal distribution with y <- rnorm(1000).

> y <- rnorm(1000)

| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| Finally, let's select 100 elements at random from these 2000 values (combining
| y and z) such that we don't know how many NAs we'll wind up with or what
| positions they'll occupy in our final vector -- my_data <- sample(c(y, z),
| 100).

> my_data <- sample(c(y, z), 100)

| Let's first ask the question of where our NAs are located in our data. The
| is.na() function tells us whether each element of a vector is NA. Call is.na()
| on my_data and assign the result to my_na.

> my_na <- is.na(my_data)

 Now, print my_na to see what you came up with.

> my_na
  [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE
 [13] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE
 [25]  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE
 [37] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
 [49] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE
 [61] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
 [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
 [85] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE
 [97]  TRUE FALSE FALSE FALSE


| Everywhere you see a TRUE, you know the corresponding element of my_data is
| NA. Likewise, everywhere you see a FALSE, you know the corresponding element
| of my_data is one of our random draws from the standard normal distribution.

| In our previous discussion of logical operators, we introduced the `==`
| operator as a method of testing for equality between two objects. So, you
| might think the expression my_data == NA yields the same results as is.na().
| Give it a try.

> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 
| The reason you got a vector of all NAs is that NA is not really a value, but
| just a placeholder for a quantity that is not available. Therefore the logical
| expression is incomplete and R has no choice but to return a vector of the
| same length as my_data that contains all NAs.

Now that we have a vector, my_na, that has a
| TRUE for every NA and FALSE for every numeric value, we can compute the total
| number of NAs in our data.
| The trick is to recognize that underneath the surface, R represents TRUE as
| the number 1 and FALSE as the number 0. Therefore, if we take the sum of a
| bunch of TRUEs and FALSEs, we get the total number of TRUEs.


Call the sum() function on my_na to count the
| total number of TRUEs in my_na, and thus the total number of NAs in my_data.
| Don't assign the result to a new variable.

> sum(my_na)
[1] 53


Finally, let's take a look at the data to convince ourselves
| that everything 'adds up'. Print my_data to the console.

> my_data
  [1]  0.38563215          NA          NA          NA          NA          NA
  [7] -0.33958250          NA          NA  0.41048682          NA -0.45360866
 [13]  0.06426909  0.98679521          NA -0.23716576          NA -1.71412953
 [19] -1.87512889          NA          NA  0.98393823  1.42809492          NA
 [25]          NA -0.50440590 -1.44792684          NA -1.18415810          NA
 [31]  0.15320807          NA  0.02007137 -0.87783977  0.30353459          NA
 [37] -0.53495424  0.20570350          NA -0.05792999 -0.52720019          NA
 [43]  1.75691187 -0.38840418          NA          NA          NA          NA
 [49]  0.72441015          NA -0.77523588 -0.99447143          NA -1.03858519
 [55]          NA          NA  1.12604380          NA          NA -0.63417557
 [61] -1.25140339  0.46304002          NA  0.06309792          NA -0.95853262
 [67]          NA -0.45784619          NA -0.24160720          NA          NA
 [73]          NA          NA          NA          NA          NA          NA
 [79]  0.20769247  0.74798471          NA          NA          NA          NA
 [85]  0.57703676          NA          NA -0.67774685  1.59835120          NA
 [91]          NA -1.85741216  0.08966206  1.42677472          NA          NA
 [97]          NA  0.70107164  1.73068997 -2.34404429

A second type of missing value -- NaN, which stands for 'not a number'. To generate NaN, try dividing (using a forward slash) 0 by 0 now.

> 0/0
[1] NaN


| Let's do one more, just for fun. In R, Inf stands for infinity. What happens
| if you subtract Inf from Inf?

> Inf-Inf
[1] NaN

